FORMAT: 1A
HOST: https://betapi.unitag.io

# Unitag Engine API

This document describes the HTTP interface for accessing the Unitag Engine API.

If you are displaying this page from [GitHub](https://github.com/unitag/Engine-API/blob/master/API.md), you are actually reading an [API Blueprint](http://apiblueprint.org/) specification. Although this format is readable as is, you may prefer switching to the [enhanced version](http://unitag.github.io/Engine-API/api).

## Base URL

The following API routes are relative to this base URL:

```no-highlight
https://betapi.unitag.io
```

This host name is voluntarily stamped as _temporary_, and will probably disappear after the beta stage (replaced by a nicer host name).

## Authentication

Every request to the Engine API must be authenticated using the following header:

```http
Authorization: Unitag token="<your token>"
```

Beta tokens can be generated by Unitag [upon request](mailto:contact@unitag.io).

## API reference

The following HTTP methods allow to manipulate operations as JSON documents. The full format of an operation object is described in [a separate document](https://github.com/unitag/Engine-API/blob/master/Reference.md).

## Examples

The following examples can be used for testing purposes. If you use the awesome [Postman](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop) for API testing, you may want to import directly [the request collection](http://unitag.github.io/Engine-API/unitag-engine-api.json.postman_collection).

### Minimal example

```json
{
    "url": "{YOUR PATH HERE}",
    "state": "PUBLISHED",
    "index": "http://www.google.com"
}
```

### Tiny game

```json
{
    "url": "{YOUR PATH HERE}",
    "state": "PUBLISHED",
    "input": {
        "continue": "<(('secret' in params.cookie))>",
        "$then": {
            "secret": "<((io.continue ? params.cookie.secret : $randomInt(0, 1000)))>"
        }
    },
    "index": {
        "input": {
            "guess": "<((params.url | $get('guess') | $parse))>"
        },
        "if": "<((io.guess != null))>",
        "then": {
            "if": "<((io.guess == io.secret))>",
            "then": {
                "trigger": {
                    "cookie": {"key": "secret", "age": 0}
                },
                "response": "Congratulations! The secret number was <((io.secret))>."
            },
            "else": {
                "trigger": {
                    "cookie": {"key": "secret", "value": "<((io.secret))>", "age": 300000}
                },
                "response": {
                    "body": {
                        "newGame": "<((!io.continue))>",
                        "hint": "<(((io.guess > io.secret) ? 'LESS' : 'MORE'))>"
                    }
                }
            }
        },
        "else": {
            "response": "Try to guess the secret number with ?guess={YOUR ATTEMPT}"
        }
    }
}
```

## Error handling

When the Engine API encounters an error, it produces an HTTP response with an appropriate status code (**`4xx`** or **`5xx`**) and a JSON body. This JSON document is always an object with the following keys:
+ `code`: a string identifying the error
+ `message`: a more verbose error description
+ `details`: if present, additional data which could help to figure out the cause of the error

For example, an invalid resolver name will produce this kind of error:

```json
{
    "code": "INVALID_RESOLVER_NAME",
    "message": "The resolver name is invalid. It must be a string containing alphanumeric characters, underscores, dashes, dots and/or tildes.",
    "details": {
        "path": "url[0].name",
        "data": {
            "expected": "UrlComponent",
            "markupAllowed": false
        }
    }
}
```

Like for most errors in the input document, the `details` object contains the following fields:
+ `path`: indicates the JSON path at which the error occurred
+ `data`: when present, provides some precisions about the circumstances of the error

What's more, in order to avoid confusions, the API only returns keys that were actually used. Thus, even if unsupported keys are not rejected, this behavior can be used to determine whether a given key as been understood or ignored by the API.

# Group Operations API

## Operation [/operations/{id}]
This resource represents one particular operation identified by its **id**.

[Operation]: #operation-operationsid

+ Parameters
    + id (string) ... ID of the operation

+ Model (application/json)

    ```json
    {
        "id": "0123456789abcdef01234567",
        "creationTime": "1970-01-01T00:00:00.000Z",
        "url": [],
        "state": "PUBLISHED",
        "...": "..."
    }
    ```

### Retrieve an operation [GET]
Retrieve an operation by its **id**.

+ Response 200

    [Operation][]

### Update an operation [PUT]
Update an operation.

+ Request (application/json)

    ```json
    {
        "url": [],
        "state": "PUBLISHED",
        "...": "..."
    }
    ```

+ Response 200

    [Operation][]

### Delete an operation [DELETE]
Delete an operation. **Warning:** this action **permanently** removes the operation from the database.

+ Response 204

## Operations collection [/operations]
This resource represents the collection of created operations.

[Operations collection]: #operations-collection-operations

+ Model (application/json)

    ```json
    [
        {
            "id": "0123456789abcdef01234567",
            "creationTime": "1970-01-01T00:00:00.000Z",
            "url": [],
            "state": "PUBLISHED",
            "...": "..."
        },
        "..."
    ]
    ```

### Retrieve all operations [GET]
Retrieve all the created operations.

+ Response 200

    [Operations collection][]

### Create a new operation [POST]
Create a new operation.

+ Request (application/json)

    ```json
    {
        "url": [],
        "state": "PUBLISHED",
        "...": "..."
    }
    ```

+ Response 201

    [Operation][]
