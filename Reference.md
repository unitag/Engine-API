API Reference
=============

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](http://doctoc.herokuapp.com/)*

- [Introduction](#introduction)
- [The `Operation` object](#the-operation-object)
  - [The publication state](#the-publication-state)
- [The `Resolver` object](#the-resolver-object)
  - [Base fields of resolvers](#base-fields-of-resolvers)
  - [QR code channel](#qr-code-channel)
  - [Image channel](#image-channel)
  - [Public hosts](#public-hosts)
- [The `Input` object](#the-input-object)
  - [The data connector](#the-data-connector)
  - [The CSV connector](#the-csv-connector)
  - [The file connector](#the-file-connector)
  - [The views connector](#the-views-connector)
  - [The last view connector](#the-last-view-connector)
  - [The parameters connector](#the-parameters-connector)
  - [The action log result connector](#the-action-log-result-connector)
  - [Evaluation order](#evaluation-order)
  - [Example of dependency graph](#example-of-dependency-graph)
  - [Complete example](#complete-example)
- [The `Step` object](#the-step-object)
  - [Base fields of steps](#base-fields-of-steps)
  - [The redirection step](#the-redirection-step)
  - [The vCard step](#the-vcard-step)
  - [The U.me step](#the-ume-step)
  - [The `switch`/`cases`/`default` step](#the-switchcasesdefault-step)
  - [The `if`/`then`/`else` step](#the-ifthenelse-step)
  - [The `goto` step](#the-goto-step)
  - [The `try`/`catch`/`then` step](#the-trycatchthen-step)
- [The `Test` object](#the-test-object)
- [The `Actions` object](#the-actions-object)
  - [Base fields of actions](#base-fields-of-actions)
  - [The email action](#the-email-action)
  - [The SMS action](#the-sms-action)
  - [The cookie action](#the-cookie-action)
  - [The upload action](#the-upload-action)
- [Miscellaneous](#miscellaneous)
  - [Predicate testing](#predicate-testing)
  - [The vCard object](#the-vcard-object)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Introduction

TODO:
 - Lien vers API.md
 - Notions générales
     + [ ] Lien vers la doc de l'API
     + [ ] Publication
     + [ ] Structure des URL d'accès aux opération publiées
     + [ ] Convention d'écriture des "schémas"
     + [ ] Définir les méta-types : Date, Integer (?), Object (!= Array + clés interdites), ...
     + [ ] Introduire Gaston

A intégrer :

```
       +--> Targets an operation <-+
       |                           |
http://:resolverHost[/:pathPrefix]/:resolverName/:entryPoint
                      |                          |
                      +--> Fixed by the host     +--> Targets an entry point
```

Exemples à placer aux bons endroits :

```json
{
    "url": {
        "host": "opn.to",
        "name": "test"
    },
    "state": "PUBLISHED",
    "index": {
        "json": {
            "body": "Here is the index step"
        }
    },
    "entryPoints": {
        "foobar": {
            "json": {
                "body": "Here is the foobar step"
            }
        }
    }
}
```

## The `Operation` object

An `Operation` is a standalone document describing an HTTP application. It is expressed as a JSON object, which allows to specify:
  - how the application can be reached
  - which routes are exposed
  - which input data are needed
  - how input data are processed
  - which output data are produced
  - which external actions are triggered

The root object looks like the following:

```javascript
Operation = {
    "url": Resolver | [Resolver],
    "state": String,
    "label": String,
    "needs": String | [String],
    "input": Input | [Input],
    "entryPoints": {Step},
    "index": Step
}
```

Field | Description | Markup
------|-------------|-------
`url` | Describes how this operation can be reached. Can be a single value or an array, but always returned as an array. See the [Resolver](#the-resolver-object) object for more details. | No
`state` | Describes the [publication state](#the-publication-state) of this operation. Possible values are `NOT_PUBLISHED`, `PUBLISHED`, `UNPUBLISHED` and `BLOCKED`. The `PUBLISHED` and `UNPUBLISHED` states can be written, the others are read-only. | No
`label` | Defines an arbitrary name for this operation (generated by default). | No
`needs` | Defines the environment values needed by this operation. TODO: more details needed here. | No
`inputs` | Defines which data is needed globally for this operation. Can be a single value or an array. See the [Input](#the-input-object) object for more details. | No
`entryPoints` | Defines the set of routes implemented by this operation. Each key in the object defines an URL path, to which is associated an arbitrary processing. See the [Step](#the-step-object) object for more details. | No
`index` | Stands as a shortcut for `entryPoints.index`. This is because the `index` step has a special meaning: it is the default step, which is accessed when no entry point is specified in the URL. | No

### The publication state

The publication state controls whether an operation is publicly available or not. This state can have the following values:

State | Description
------|------------
`NOT_PUBLISHED` | The operation has never been published (default).
`PUBLISHED` | The operation is currently published. This is the only state where it can be accessed from the URL(s) defined by its resolver(s).
`UNPUBLISHED` | The operation has already been published, but is not published anymore.
`BLOCKED` | The operation was published, but has been blocked for some reason by an administrator.

## The `Resolver` object

A `Resolver` allows to specify how the operation can be reached. Each resolver basically defines an URL from which the underlying operation is made accessible. Additionally, it is possible to create a typed resolver, which allows to associate one ore more communication media to the access URL.

```javascript
Resolver = String | RawResolver | QrcodeResolver | ImageResolver
```

### Base fields of resolvers

A `Resolver` generally looks like the following:

```javascript
RawResolver = {
    "host": String,
    "name": String,
    "label": String
}
```

When a resolver is specified as single `String`, it is interpreted as the `name` of a `RawResolver`.

Field | Description | Markup
------|-------------|-------
`host` | Defines the host on which the resolver is created (optional). [Public hosts](#public-hosts) are available by default, but custom domains can be added upon request. | No
`name` | Defines the name of this resolver, which is used as the URL path. | No
`label` | Specifies an arbitrary label for this resolver (optional). | No

### QR code channel

A resolver can be used as a QR code channel. This means that one or more QR code(s) can be associated to the resolver in order to help the diffusion of the underlying operation. A QR code resolver looks like the following:

```javascript
QrcodeResolver = RawResolver + {
    "type": "qrcode",
    "design": QrcodeDesign | [QrcodeDesign]
}
```

Field | Description | Markup
------|-------------|-------
`type` | Defines the type of channel (QR code here). | No
`design` | Describes the design(s) of the generated QR code(s). TODO: more details needed here. | No

### Image channel

A resolver can be used as an image recognition channel. This means that one or more interactive image(s) can be associated to the resolver in order to make them recognizable by [Unitag QR Code Scanner](https://www.unitag.io/qrcode/app). When such an image is scanned by this application, the user is redirected to the underlying operation. An image resolver looks like the following:

```javascript
ImageResolver = RawResolver + {
    "type": "image",
    "image": Number | [Number]
}
```

Field | Description | Markup
------|-------------|-------
`type` | Defines the type of channel (image recognition here). | No
`image` | Describes the uploaded image(s) that should be associated to this resolver. TODO: more details needed here. | No

### Public hosts

By default, the following domain names can be used in the `host` field of a resolver:

Domain name | Path prefix | Description
------------|-------------|------------
`e.unitag.io` | `/r` | This is the default domain name, which is used when no `host` is specified.
`opn.to` | `/r` | This is a freely usable white-label domain.

## The `Input` object

An input object allows to define a set of data to be injected in the evaluation context. It definition looks like the following:

```javascript
Input = {Connector} + {
    "$then": Input | [Input]
}

Connector = DataConnector | CsvConnector | FileConnector |
            ViewsConnector | LastViewConnector | ParamsConnector |
            ActionLogResultConnector
```

So, an input object is basically a map of connectors, where the key defines the name of the resulting value (accessible through `<((io.name))>` after evaluation), and the value defines how to produce the resulting value.

### The data connector

The data connector is the simplest connector: it allows to inject some arbitrary data into the evaluation context. Such a connector looks like the following:

```javascript
DataConnector = Boolean | Number | String | Object | Array | {
    "$data": Boolean | Number | String | Object | Array
}
```

In fact, any raw value is automatically interpreted as a data connector. A non-data connector is defined by an object containing a single `$`-prefixed key. This key defines the connector type, while the associated value defines the connector definition. Although useless in practice, a data connector can also be expressed this way (using a `$data` key).

### The CSV connector

The CSV connector allows to retrieve a remote CSV file and to inject its parsed content into the evaluation context. Such a connector looks like the following:

```javascript
CsvConnector = {
    "$csv": String | {
        url: String | Url
    }
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `url` field.

Field | Description | Markup
------|-------------|-------
`url` | Defines the URL of the remote CSV file. It can be any valid URL string, or a parsed URL object. TODO: more details here. | Allowed, only the string format is accepted.

### The file connector

The file connector allows to load a file and to inject its content into the evaluation context. Such a connector looks like the following:

```javascript
FileConnector = {
    "$file": String | RemoteFile | UploadedFile
}

RemoteFile = {
    url: String | Object,
    encoding: String
}

UploadedFile = {
    filename: String,
    encoding: String
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `url` field of a `RemoteFile`.

Field | Description | Markup
------|-------------|-------
`url` | Defines the URL of a remote file. It can be any valid URL string, or a parsed URL object. TODO: more details here. | Yes, but only the string format is accepted.
`filename` | Defines the name of an uploaded file, which can be obtained from the `<((params.file))>` object. | Yes.
`encoding` | Optionally specifies the encoding of the loaded file: `utf8`, `base64`, `hex` or `ascii`. Default is `base64`. | Yes.

### The views connector

The views connector allows to retrieve the number of times a given step or this operation has been accessed.

```javascript
ViewsConnector = {
    "$views": String | {
        step: String,
        from: Date,
        to: Date,
        duration: Number,
        unit: String
    }
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `step` field.

Field | Description | Markup
------|-------------|-------
`step` | Defines the step to consider. By default, consider all accesses to this operation. | Yes.
`from` | Defines the lower bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`to` | Defines the upper bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`duration` | Defines the length of the time period taken into account. Default is unlimited if no `unit` is specified, `1` otherwise. | Yes.
`unit` | Defines the unit of the `duration` field. Can be `millisecond`, `second`, `minute`, `hour` or `day`. Default is `millisecond`. | Yes.

There are several ways for specifying the time period:
  - When both `from` and `to` are specified, they define the exact bounds of the time period.
  - When either `from` or `to` is specified, the time period is defined by that bound, and an eventual duration.
  - When neither `from` nor `to` nor a duration is specified, the time period is unlimited.
  - When only a duration is specified, a time period of this duration is automatically selected around the current time. This period is always a slice of the upper time unit. For example, if the duration is 10 minutes, each hour is splitted into 6 slices of 10 minutes. Then, the selected time period is the slice that contain the current time. If the upper unit is not dividable by the requested duration, an incomplete slice is produced. For example, a duration of 25 minutes splits each hour into 2 slices of 25 minutes and a slice of 10 minutes.

### The last view connector

The last view connector allows to retrieve the date (and time) of the last access to a given step or to this operation.

```javascript
LastViewConnector = {
    "$lastView": String | {
        step: String,
        from: Date,
        to: Date
    }
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `step` field.

Field | Description | Markup
------|-------------|-------
`step` | Defines the step to consider. By default, consider all accesses to this operation. | Yes.
`from` | Defines the lower bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`to` | Defines the upper bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.

### The parameters connector

The parameters connector allows to retrieve all input parameters supplied upon access to a given step.

```javascript
ParamsConnector = {
    "$params": String | {
        step: String,
        from: Date,
        to: Date,
        output: String | [String] | {String},
        sort: Number,
        skip: Number,
        limit: Number
    }
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `step` field.

Field | Description | Markup
------|-------------|-------
`step` | Defines the step to consider. `"index"` by default. | Yes.
`from` | Defines the lower bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`to` | Defines the upper bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`output` | Defines how the results are generated from the HTTP parameters. See below for details on how to specify this field. Default is `"params"`. | Yes.
`sort` | Defines the sorting order of results. Can be either `-1` (newest first), `1` (oldest first) or `0` (unordered). Unordered by default. | Yes.
`skip` | Defines a number of results to be skipped. Especially useful in combination with `sort` and `limit` for pagination. No result is skipped by default. | Yes.
`limit` | Defines the maximal number of results to be returned. All results are returned by default. | Yes.

For each access, the following data is available:

```javascript
{
    "creationTime": Date,
    "params": {
        "url": {},
        "body": {},
        "cookie": {},
        "files": {}
    }
}
```

Field | Description
------|------------
`creationTime` | The date (and time) of the access.
`params` | The HTTP parameters. Reflects what was injectable through `<((io.params))>` at runtime.

The connector produces an array in which each item has been built from the input parameters supplied upon an access. The `output` field allows to define how to build these items. It consists in one or more strings that reference fields of the above object using the dot-notation. The structure of the `output` field (single value, array or map) is then replicated for each resulting item, with all references replaced by the targeted values.

For example, let's consider the following `output` field:

```json
{
    "date": "creationTime",
    "form": "params.body"
}
```

Assuming that the connector was configured on a step that accepts an HTTP form, we could obtain this kind of result:

```javascript
[
    {
        "date": Date("Thu, 01 Jan 1970 00:00:00 GMT"),
        "form": {
            "firstname": "Chuck",
            "lastname": "Norris"
        }
    },
    {
        "date": Date:("Sun, 25 Aug 1991 20:57:08 GMT"),
        "form": {
            "firstname": "Linus",
            "lastname": "Torvalds"
        }
    }
]
```

### The action log result connector

The action log result connector allows to retrieve the results produced by the given [action(s)](#the-actions-object). Note that only results of actions with the `log` flag can be retrieved.

```javascript
ActionLogResultConnector = {
    "$actionLogResult": String | {
        actionName: String,
        actionType: String,
        step: String,
        from: Date,
        to: Date,
        sort: Number,
        skip: Number,
        limit: Number
    }
}
```

When specified as a single `String`, the connector definition is directly interpreted as the `actionName` field.

Field | Description | Markup
------|-------------|-------
`actionName` | Defines the name of the action(s) to consider. By default, consider actions with any name. | Yes.
`actionType` | Defines the type of the action(s) to consider. By default, consider actions with any type. | Yes.
`step` | Defines the step to consider. By default, consider all accesses to this operation. | Yes.
`from` | Defines the lower bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`to` | Defines the upper bound of the time period taken into account. Unlimited by default. | Yes, but only a numeric timestamp is accepted.
`sort` | Defines the sorting order of results. Can be either `-1` (newest first), `1` (oldest first) or `0` (unordered). Unordered by default. | Yes.
`skip` | Defines a number of results to be skipped. Especially useful in combination with `sort` and `limit` for pagination. No result is skipped by default. | Yes.
`limit` | Defines the maximal number of results to be returned. All results are returned by default. | Yes.

### Evaluation order

The connectors defined in the same input object are implicitly evaluated in parallel. Thus, a connector cannot use a value produced by one of its siblings.

However, there are two ways for controlling the evaluation order of connectors:
  - An input object can define a special `$then` key. It allows to define another input object (or an array) which is processed only once all the connectors of the current object have been evaluated. The resulting values of these connectors can be injected in the `$then` field using the markup syntax.
  - When an array of input objects is specified, its items are evaluated in parallel. When coupled with `$then`, this allows to define several independent evaluation chains.

As shown in the following example, these techniques can cohabit in order to define complex and/or deep dependency graphs. However, most use cases will involve implicit parallel definitions, which are easy to express and evaluated efficiently.

### Example of dependency graph

To illustrate the previous section, let's consider the following input object (for the sake of simplicity, connector definitions have voluntary been replaced by empty objects `{}`):

```json
[
    {
        "a": {},
        "b": {},
        "$then": [
            {
                "c": {}
            },
            {
                "d": {},
                "e": {},
                "$then": {
                    "f": {}
                }
            }
        ]
    },
    {
        "g": {}
    }
]
```

This declaration can mentally be represented as follows:

```
                             +---+
                        ,----| c |
            +---+      /     +---+
            | a |     /
       ,----|   |----:
      /     | b |     \      +---+
     /      +---+      \     | d |    +---+
----:                   `----|   |----| f |
     \                       | e |    +---+
      \     +---+            +---+
       `----| g |
            +---+
```

Now, more verbosely, here is what would happen at evaluation time:
  1. Two evaluation chains start in parallel (two items in the top-level array).
    - The first chain follows the following steps:
      1. Connectors `a` and `b` are evaluated in parallel.
      2. When `a` and `b` have completed, two new evaluation chains start in parallel (two items in the `$then` field):
        - The first chain simply evaluates the `c` connector.
        - The second chain follows the following steps:
          1. Connectors `d` and `e` are evaluated in parallel.
          2. When `d` and `e` have completed, the `f` connector is evaluated.
    - The second chain simply evaluates the `g` connector.
  2. All connectors have properly been evaluated, and the resulting values can now been accessed using the markup syntax (`<((io.a))>` ... `<((io.g))>`).

This example just aims at providing an overview of ordering capabilities. It is voluntarily complex and does not reflect a particular use case (see below for [a more realistic example](#complete-example)). However, it illustrates well how evaluation chains can be powerful. For instance, if evaluating the `g` connector is particularly expensive, it will not block nor affect in any way the other evaluation chain. Both will progress concurrently, and will be waited transparently for processing the following tasks.

### Complete example

TODO

## The `Step` object

TODO

```javascript
Step = RedirectStep | VcardStep | JsonStep | UmeStep |
       SwitchStep | IfStep | GotoStep | TryStep
```

### Base fields of steps

```javascript
BaseStep = {
    "label": String,
    "input": Input | [Input],
    "trigger": Actions | [Actions]
}
```

### The redirection step

```javascript
RedirectStep = String | BaseStep + {
    "redirect": Step
}
```

### The vCard step

```javascript
VcardStep = BaseStep + {
    "vcard": Vcard
}
```

### The U.me step

```javascript
UmeStep = BaseStep + {
    "ume": Ume
}
```

### The `switch`/`cases`/`default` step

```javascript
SwitchStep = BaseStep + {
    "switch": Boolean | Number | String | Object,
    "cases": {Step} | [Option],
    "default": Step
}
```

### The `if`/`then`/`else` step

```javascript
IfStep = BaseStep + {
    "if": Boolean,
    "then": Step,
    "else": Step
}
```

### The `goto` step

```javascript
GotoStep = BaseStep + {
    "goto": String
}
```

### The `try`/`catch`/`then` step

```javascript
TryStep = BaseStep + {
    "try": Test | [Test],
    "catch": Step,
    "then": Step
}
```

## The `Test` object

```javascript
Test = {
    "enabled": Boolean,
    "label": String,
    "input": Input | [Input],
    "trigger": Actions | [Actions],
    "value": Boolean | Number | String | Object,
    "assert": Boolean | Number | String | Assertion | [Assertion],
    "catch": Step
}
```

## The `Actions` object

```javascript
Actions = {
    "enabled": Boolean,
    "logged": Boolean,
    "waited": Boolean,

    "email": EmailAction | [EmailAction],
    "sms": SmsAction | [SmsAction],
    "cookie": CookieAction | [CookieAction],
    "upload": UploadAction | [UploadAction]
}
```

### Base fields of actions

```javascript
BaseAction = {
    "output": String,
    "logged": Boolean,
    "waited": Boolean
}
```

### The email action

```javascript
EmailAction = BaseAction + {
    "from": String | [String] | Object | [Object],
    "to": String | [String] | Object | [Object],
    "subject": Boolean | Number | String | Object,
    "body": Boolean | Number | String | Object,
    "attachment": Attachment | [Attachment]
}
```

```javascript
Attachment = {
    "text": TextAttachement | [TextAttachement],
    "vcard": Vcard | [Vcard],
    "upload": File | [File]
}
```

```javascript
TextAttachement = String | {
    "filename": String,
    "content": String
}
```

### The SMS action

```javascript
SmsAction = Action + {
    "destination": String,
    "text": Boolean | Number | String | Object
}
```

### The cookie action

```javascript
CookieAction = Action + {
    "key": Boolean | Number | String,
    "value": Boolean | Number | String | Object,
    "age": Number
}
```

### The upload action

```javascript
UploadAction = Action + {
    "file": String | File,
    "alterations": [Alteration]
}

File = {
    "path": String,
    "filename": String,
    "contentType": String
}

Alteration = /TODO/
```

## Miscellaneous

### Predicate testing

```javascript
Predicate = {
    "eq": Boolean | Number | String | Object,
    "ne": Boolean | Number | String | Object,
    "lt": Boolean | Number | String | Object,
    "gt": Boolean | Number | String | Object,
    "lte": Boolean | Number | String | Object,
    "gte": Boolean | Number | String | Object

    // Other tests
}
```

### The vCard object

```javascript
Vcard = /TODO/
```
